<html><head></head><body><h1 id="microsoft-edge-agent-design">Microsoft Edge Agent Design</h1>
<p>The WebPageTest agent (<a href="https://github.com/WPO-Foundation/wptagent">wptagent</a>) needs to be able to do several things to automate and measure performance:</p>
<ol>
<li><a href="#browser-launch">Launch the browser with (optionally) a clean profile (cache, cookies, etc).</a></li>
<li><a href="#page-navigation">Automate navigating to pages.</a></li>
<li><a href="#executing-javascript">Run Javascript in the context of the page and get the output.</a></li>
<li><a href="#monitoring-activity">Monitor the page load status and network activity.</a></li>
<li><a href="#request-information">Get detailed timing information and headers for all network requests.</a></li>
<li><a href="#response-bodies">Retrieve response bodies for all network requests (for optimization checks).</a></li>
<li><a href="#video-capture">Record video of the browser viewport.</a></li>
<li><a href="#request-interception">Intercept outbound network requests to block or modify headers.</a></li>
<li><a href="#main-thread-interactivity">Monitor the browser main thread interactivity.</a></li>
</ol>
<h2 id="high-level-design">High-level design</h2>
<p>wptagent uses <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">webdriver</a> to drive the browser. It uses <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363668(v=vs.85).aspx">ETW</a> events captured in realtime by <a href="https://github.com/WPO-Foundation/wpt-etw">wpt-etw</a> for monitoring activity, getting request details and response bodies.  For request interception and monitoring of the main thread it uses an <a href="https://github.com/WPO-Foundation/wptagent/tree/master/internal/support/edge/extension">extension</a>.</p>
<p><img src="images/edge-overview.svg" alt="Overview"></p>
<h1 id="browser-launch">Browser Launch</h1>
<p>wptagent clears the cache (for first view tests) by deleting the following folders under <code>%LOCALAPPDATA%\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe</code>:</p>
<ul>
<li><code>AC\#!*</code> (all folders starting with <code>#!</code> in the AC directory)</li>
<li><code>AC\MicrosoftEdge\Cookies</code></li>
<li><code>AppData</code></li>
</ul>
<p>wptagent ships with the binaries for webdriver for all released versions of Edge (each build needs to be paired with the matching webdriver server) and should auto detect which is needed for the currently version of Windows 10. If there is a MicrosoftWebDriver.exe file in internal\support\edge\current it will use that instead of auto detecting one of the installed versions.</p>
<p>Webdriver is used to launch the browser with the <a href="https://docs.microsoft.com/en-us/microsoft-edge/extensions/guides/packaging/creating-and-testing-extension-packages#automated-testing-with-webdriver">wptagent extension sideloaded</a>.  This requires copying the extension to the Edge %LOCALAPPDATA% directory as it will only run sideloaded extensions from there.</p>
<p>The browser is moved to 0,0 and the widow dimensions are also set through webdriver to match whatever is requested by the testing.</p>
<p>After launching the browser, wptagent starts wpt-etw to monitor the browser activity and passes it a directory path for storing response bodies.  After the browser is launched wptagent waits to get a message from wpt-etw indicating that it started before continuing.</p>
<p>Finally, wptagent also waits for the cpu utilization to drop below 20% of any individual core for 500ms to let the browser finish initializing and go idle before starting testing.</p>
<h1 id="page-navigation">Page Navigation</h1>
<p>Navigation is done through webdriver by executing javascript that sets the window.location to the desired URL.  This allows for initiating the page load but not waiting for it to complete before returning.  Using the webdriver <code>get</code> function is a blocking operation that waits for the page load to finish before returning, limiting the flexibility of the agent.</p>
<h1 id="executing-javascript">Executing Javascript</h1>
<p>Javascript execution is done using the existing webdriver support, both for metrics collection and multi-step scripts.</p>
<h1 id="monitoring-activity">Monitoring Activity</h1>
<p>Live updates from Edge for page navigation status and request activity is probably the most complicated piece of the architecture (and had the most false-starts).</p>
<p>wptagent uses an external app (<a href="https://github.com/WPO-Foundation/wpt-etw">wpt-etw</a>) that runs in an elevated session to monitor ETW (Event Trace for Windows) events emitted by the Edge engine (WinInet and MSHtml specifically).  wpt-etw filters the trace events for the ones of interest and batches them up in 100ms bundles of events.  The event bundles are then POSTed to the http server running in wptagent (at <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a>) as a JSON array of trace events.  The trace events trigger activity updates in the wptagent activity monitoring code and wptagent watches for the page load notifications to know when navigation is complete.</p>
<p>There is the potential for some additional buffering as the Windows kernel buffers trace events internally but it is not an issue in practice.  The kernel buffering is for a maximum of 3 seconds but when activity is ongoing there are enough events generated that in practice it is delayed for a much shorter period (and timely delivery within a few seconds is not critical to wptagent operation since the individual events are timestamped).</p>
<p><img src="images/edge-etw-requests.svg" alt="etw requests"></p>
<h2 id="failed-design-%231---extension-direct-to-wptagent">Failed design #1 - extension direct to wptagent</h2>
<p>The initial plan for detecting the browser activity for Microsoft Edge was to use the same architecture as the Firefox agent where an extension listens to <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webNavigation">webNavigation</a> and <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest">webRequest</a> events and forwards them to wptagent using fetch to POST the data to <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a>.</p>
<p>It turns out that Edge blocks all local network activity from extensions making it impossible to fetch to localhost (or even to a local server on the same network).</p>
<h2 id="failed-design-%232---extension-to-native-messaging-bridge">Failed design #2 - extension to native messaging bridge</h2>
<p>Building on Failed Design #1, for localhost communications Edge requires using <a href="https://docs.microsoft.com/en-us/microsoft-edge/extensions/guides/native-messaging">native messaging</a>.  This requires building a UWP app for the extension to talk to and the plan was to have an app that proxies the data to the http server on <a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a> (turning native messaging messages into http POST messages).</p>
<p>It turns out that native messaging is locked down so the extension has to be bundled with the app that it talks to.  Unfortunately there is no way to sideload a bundled extension because they do not run in the Edge %LOCALAPPDATA% directory and there is no way to install a UWP app there making it impossible to communicate locally from a sideloaded extension.</p>
<p>Running the browser from a webdriver session starts with a clean profile and doesn't load installed extensions so there is also no way to load a bundled/installed extension in a webdriver session.</p>
<h1 id="request-information">Request Information</h1>
<p>The request timing and headers are parsed out of the ETW events from wpt-etw.  Initial implementations recorded the data using xperf and post-processed it after the test but with the ability to filter and process events in realtime using wpt-etw they can now be filtered and processed live (much faster).</p>
<p>The event processing depends on parsing fields out of the trace messages and they are subject to change as development on Edge (or IE) continue making it the most fragile piece of the architecture (though in practice it has been quite stable).</p>
<p>The WinInet events in particular are not parsed correctly automatically so a good number of them are hand-processed in the code from the underlying buffers (mostly anything involving strings - DNS and request/response headers in particular).</p>
<h1 id="response-bodies">Response Bodies</h1>
<p>WinInet will log the raw byte streams (post transfer-encodeing which WinInet strips out automatically) if the <code>Microsoft-Windows-WinInet-Capture</code> ETW category is enabled.  To minimize overhead the response bodies are processed by wpt-etw directly and written to disk in a directory provided by wptagent.  Each request is written to a file that is named based on it's request ID so they can be matched-up by wptagent when the post-processing optimization checks are done (or gathered and sent back to the server if the test requires keeping the response bodies).</p>
<p>The response bodies are streamed to disk as they come in. WinInet also streams the raw request and response headers but those are ignored and only the response body bytes are streamed to disk (which is consistent with how wptagent processes bodies for other browsers).</p>
<p><img src="images/edge-etw-bodies.svg" alt="etw bodies"></p>
<h1 id="video-capture">Video Capture</h1>
<p>Video capture is done using the same video capture support in wptagent used for all desktop browsers (to make apples-to-apples comparisons possible).  Specifically it uses ffmpeg with gdigrab to record the region of the desktop where the browser window was placed (using webdriver).  ffmpeg is configured to record as a x264rgb video with ultrafast settings and highest quality to minimize the amount of overhead on the system from video capture.  By default it will record at 10fps but can be configured using the --fps command-line option or on a per-test basis.</p>
<p>To ensure that video capture has started before the testing is started the size of the video file is monitored and once it exceeds 10KB the testing is started.  If this step is skipped it is quite possible (and likely) that the video capture will start capturing after the start of the test.</p>
<p>To synchronize the video with the measured activity an orange overlay is placed on the page before ffmpeg recording is started (a solid-color div positioned over the page contents, even if starting from a blank page).  Immediately before navigation the div is removed and in post-processing the orange frames are removed from the captured video so the video frames ane navigation both start at the same point.  The same overlay is used for multi-step scripts and is placed over the existing page before each step.  The overlays are written into the page using the script execution support exposed by webdriver.  The overlay is also used to locate the viewport for cropping of the video capture.</p>
<p><img src="images/edge-orange.png" alt="orange"></p>
<h1 id="request-interception">Request Interception</h1>
<p>wptagent uses an extension with blocking webRequest listeners to intercept any requests that need to be blocked or modified.  The listeners are only installed if they are going to be needed.  The difficult part lies in communicating the configuration data to the extension since the extension can not communicate directly with wptagent.</p>
<p>As part of the startup, wptagent uses webdriver to load <a href="http://127.0.0.1:8888/config.html">http://127.0.0.1:8888/config.html</a> which is a locally-served page that has the configuration data for the request interception encoded as json in a hidden div with a well-known ID.  The extension has a content script (<a href="https://github.com/WPO-Foundation/wptagent/blob/master/internal/support/edge/extension/config-script.js">config-script.js</a>) that is configured to run after that specific page has been loaded.  The content script extracts the JSON config data from the DOM and sends it to the extension's background page where it is processed.</p>
<p>The background page builds a list of modifications that are necessary and installs webRequest listeners if needed.</p>
<p><img src="images/edge-intercept.svg" alt="intercept"></p>
<h1 id="main-thread-interactivity">Main Thread Interactivity</h1>
<p>To measure the responsiveness of the browser's main thread wptagent uses a content script (<a href="https://github.com/WPO-Foundation/wptagent/blob/master/internal/support/edge/extension/long-tasks.js">long-tasks.js</a>) that attaches to every page load as soon as possible (at document_start).</p>
<p>The content script posts a series of requestAnimationFrame calls and measures whenever it takes more than 50ms and builds a list of the "long tasks".</p>
<p>Content scripts run in an isolated sandbox from the page (and from webdriver) so communicating the long tasks back to wptagent involves a few hoops:</p>
<ul>
<li>The content script installs a message handler and watches for a message <code>{wptagent: "GetInteractivePeriods"}</code>.</li>
<li>When the message is received the long tasks are processed and converted into idle periods (inverted basically).</li>
<li>The idle periods are encoded as JSON and written into a hidden DOM element with a well-known ID.</li>
<li>At the end of the test when it needs to collect the interactive periods, wptagent executes a script that posts the message to the content script and it polls the DOM waiting for the hidden DOM element to be written and extracts the timing data from it when it is available.</li>
</ul>
<p><img src="images/edge-long-tasks.svg" alt="intercept"></p>
<h1 id="known-issues">Known Issues</h1>
<h2 id="cookie-clearing">Cookie Clearing</h2>
<p>The Fall Creators Update of Windows 10 introduced a change where Edge uses a centralized cookie store that is not cleared either by using the IE clearing logic or in any of the Edge-specific application directories so cookies currently persist.  Using an extension to clear them also doesn't work as there is no way to enumerate all cookies in Edge.</p>
</body></html>